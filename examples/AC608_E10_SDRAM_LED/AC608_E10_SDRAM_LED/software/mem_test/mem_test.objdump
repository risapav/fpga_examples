
mem_test.elf:     file format elf32-littlenios2
mem_test.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000020

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00000020 paddr 0x00000020 align 2**12
         filesz 0x00000688 memsz 0x00000688 flags r-x
    LOAD off    0x000016a8 vaddr 0x000006a8 paddr 0x000006ac align 2**12
         filesz 0x00000004 memsz 0x00000004 flags rw-
    LOAD off    0x000016b0 vaddr 0x000006b0 paddr 0x000006b0 align 2**12
         filesz 0x00000000 memsz 0x0000000c flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00000000  00000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         00000688  00000020  00000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rwdata       00000004  000006a8  000006ac  000016a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  3 .bss          0000000c  000006b0  000006b0  000016b0  2**2
                  ALLOC, SMALL_DATA
  4 .comment      00000023  00000000  00000000  000016ac  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000188  00000000  00000000  000016d0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000020a  00000000  00000000  00001858  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000ce4  00000000  00000000  00001a62  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000650  00000000  00000000  00002746  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001946  00000000  00000000  00002d96  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000214  00000000  00000000  000046dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000005ca  00000000  00000000  000048f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000003ef  00000000  00000000  00004eba  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_alt_sim_info 00000060  00000000  00000000  000052ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000140  00000000  00000000  00005310  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .thread_model 00000003  00000000  00000000  000061ec  2**0
                  CONTENTS, READONLY
 16 .cpu          00000005  00000000  00000000  000061ef  2**0
                  CONTENTS, READONLY
 17 .qsys         00000001  00000000  00000000  000061f4  2**0
                  CONTENTS, READONLY
 18 .simulation_enabled 00000001  00000000  00000000  000061f5  2**0
                  CONTENTS, READONLY
 19 .stderr_dev   0000000b  00000000  00000000  000061f6  2**0
                  CONTENTS, READONLY
 20 .stdin_dev    0000000b  00000000  00000000  00006201  2**0
                  CONTENTS, READONLY
 21 .stdout_dev   0000000b  00000000  00000000  0000620c  2**0
                  CONTENTS, READONLY
 22 .sopc_system_name 00000008  00000000  00000000  00006217  2**0
                  CONTENTS, READONLY
 23 .quartus_project_dir 0000001d  00000000  00000000  0000621f  2**0
                  CONTENTS, READONLY
 24 .sopcinfo     000422e3  00000000  00000000  0000623c  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    d  .entry	00000000 .entry
00000020 l    d  .text	00000000 .text
000006a8 l    d  .rwdata	00000000 .rwdata
000006b0 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000068 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 memtest_small.c
00000000 l    df *ABS*	00000000 alt_load.c
0000039c l     F .text	00000020 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
0000055c l     F .text	0000007c udivmodsi4
00000428 g     F .text	0000002c alt_main
000006ac g       *ABS*	00000000 __flash_rwdata_start
00000000 g     F .entry	0000001c __reset
00000020 g       *ABS*	00000000 __flash_exceptions_start
000006b4 g     O .bss	00000004 alt_argv
000086a8 g       *ABS*	00000000 _gp
00000454 g     F .text	00000004 usleep
00000698 g     F .text	00000008 __udivsi3
00000524 g     F .text	00000038 alt_icache_flush
00000000 g       *ABS*	00000000 __alt_mem_ram
000006bc g       *ABS*	00000000 __bss_end
000004f8 g     F .text	00000018 alt_dcache_flush_all
000006ac g       *ABS*	00000000 __ram_rwdata_end
000006a8 g       *ABS*	00000000 __ram_rodata_end
000006a8 g     O .rwdata	00000004 jtag_uart_0
000006a0 g     F .text	00000008 __umodsi3
000006bc g       *ABS*	00000000 end
00004000 g       *ABS*	00000000 __alt_stack_pointer
00000020 g     F .text	0000004c _start
00000458 g     F .text	00000004 alt_sys_init
0000006c g     F .text	0000005c led_flash
000006a8 g       *ABS*	00000000 __ram_rwdata_start
000006a8 g       *ABS*	00000000 __ram_rodata_start
0000047c g     F .text	0000007c alt_busy_sleep
000006bc g       *ABS*	00000000 __alt_stack_base
000006b0 g       *ABS*	00000000 __bss_start
000000c8 g     F .text	000002d4 main
000006b8 g     O .bss	00000004 alt_envp
000005d8 g     F .text	00000060 __divsi3
000006a8 g       *ABS*	00000000 __flash_rodata_start
0000045c g     F .text	00000020 alt_irq_init
000006b0 g     O .bss	00000004 alt_argc
00000020 g       *ABS*	00000000 __ram_exceptions_start
000006ac g       *ABS*	00000000 _edata
000006bc g       *ABS*	00000000 _end
00000020 g       *ABS*	00000000 __ram_exceptions_end
0000051c g     F .text	00000008 altera_nios2_qsys_irq_init
0000001c g       .entry	00000000 exit
00000638 g     F .text	00000060 __modsi3
00004000 g       *ABS*	00000000 __alt_data_end
01000000 g       *ABS*	00000000 __alt_mem_sdram
0000001c g       .entry	00000000 _exit
00000510 g     F .text	0000000c alt_icache_flush_all
000003bc g     F .text	0000006c alt_load



Disassembly of section .entry:

00000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   0:	00840014 	movui	r2,4096
#endif

0:
    initi r2
   4:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   8:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   c:	00bffd16 	blt	zero,r2,4 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  10:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
  14:	08400814 	ori	at,at,32
    jmp r1
  18:	0800683a 	jmp	at

0000001c <_exit>:
  1c:	00000000 	call	0 <__reset>

Disassembly of section .text:

00000020 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
  20:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
  24:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
  28:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  2c:	00bffd16 	blt	zero,r2,24 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  30:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
  34:	ded00014 	ori	sp,sp,16384

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
  38:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
  3c:	d6a1aa14 	ori	gp,gp,34472
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  40:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
  44:	1081ac14 	ori	r2,r2,1712

    movhi r3, %hi(__bss_end)
  48:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
  4c:	18c1af14 	ori	r3,r3,1724

    beq r2, r3, 1f
  50:	10c00326 	beq	r2,r3,60 <_start+0x40>

0:
    stw zero, (r2)
  54:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  58:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  5c:	10fffd36 	bltu	r2,r3,54 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  60:	00003bc0 	call	3bc <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  64:	00004280 	call	428 <alt_main>

00000068 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  68:	003fff06 	br	68 <alt_after_alt_main>

0000006c <led_flash>:
  }
  return ret_code;
}

void led_flash(int t)
{
  6c:	defffd04 	addi	sp,sp,-12
  70:	dc000015 	stw	r16,0(sp)
  74:	2021883a 	mov	r16,r4
  78:	dfc00215 	stw	ra,8(sp)
  7c:	dc400115 	stw	r17,4(sp)
  80:	00000a06 	br	ac <led_flash+0x40>
	while(t>0)
	{
		IOWR_32DIRECT(LED_BASE,0,0);
  84:	88000035 	stwio	zero,0(r17)
		usleep(200000);
  88:	010000f4 	movhi	r4,3
  8c:	21035004 	addi	r4,r4,3392
  90:	00004540 	call	454 <usleep>
		IOWR_32DIRECT(LED_BASE,0,1);
  94:	00800044 	movi	r2,1
  98:	88800035 	stwio	r2,0(r17)
		usleep(200000);
  9c:	010000f4 	movhi	r4,3
  a0:	21035004 	addi	r4,r4,3392
  a4:	00004540 	call	454 <usleep>
		t--;
  a8:	843fffc4 	addi	r16,r16,-1

void led_flash(int t)
{
	while(t>0)
	{
		IOWR_32DIRECT(LED_BASE,0,0);
  ac:	04540004 	movi	r17,20480
  return ret_code;
}

void led_flash(int t)
{
	while(t>0)
  b0:	043ff416 	blt	zero,r16,84 <led_flash+0x18>
		usleep(200000);
		IOWR_32DIRECT(LED_BASE,0,1);
		usleep(200000);
		t--;
	}
}
  b4:	dfc00217 	ldw	ra,8(sp)
  b8:	dc400117 	ldw	r17,4(sp)
  bc:	dc000017 	ldw	r16,0(sp)
  c0:	dec00304 	addi	sp,sp,12
  c4:	f800283a 	ret

000000c8 <main>:
*  Purpose: Continually prints the menu and performs the actions
*           requested by the user.
* 
******************************************************************/
int main(void)
{
  c8:	defffe04 	addi	sp,sp,-8
  cc:	dfc00115 	stw	ra,4(sp)
  d0:	dc000015 	stw	r16,0(sp)
  d4:	04000044 	movi	r16,1
  d8:	00e04034 	movhi	r3,33024

  /* Perform a walking 1's test at the given address. */
  for (pattern = 1; pattern != 0; pattern <<= 1)
  {
    /* Write the test pattern. */
    IOWR_32DIRECT(address, 0, pattern);
  dc:	1c000035 	stwio	r16,0(r3)

    /* Read it back (immediately is okay for this test). */
    if (IORD_32DIRECT(address, 0) != pattern)
  e0:	18800037 	ldwio	r2,0(r3)
  e4:	1400031e 	bne	r2,r16,f4 <main+0x2c>
{
  unsigned int pattern;
  unsigned int ret_code = 0x0;

  /* Perform a walking 1's test at the given address. */
  for (pattern = 1; pattern != 0; pattern <<= 1)
  e8:	8421883a 	add	r16,r16,r16
  ec:	80000726 	beq	r16,zero,10c <main+0x44>
  f0:	003ffa06 	br	dc <main+0x14>
  /* Test Data Bus. */
  ret_code = MemTestDataBus(memory_base);

  if (ret_code)
  {
	  led_flash(3);
  f4:	010000c4 	movi	r4,3
  f8:	000006c0 	call	6c <led_flash>
    if  (ret_code)
    	led_flash(5);
  }

  /* Test byte and half-word access. */
  if (!ret_code)
  fc:	80004126 	beq	r16,zero,204 <main+0x13c>
 100:	00007e06 	br	2fc <main+0x234>
  IOWR_32DIRECT(memory_base, test_offset, antipattern);
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
  {
     if (IORD_32DIRECT(memory_base, offset) != pattern)
     {
        ret_code = (memory_base+offset);
 104:	180d883a 	mov	r6,r3
 108:	00001b06 	br	178 <main+0xb0>
    if  (ret_code)
    	led_flash(5);
  }

  /* Test byte and half-word access. */
  if (!ret_code)
 10c:	00c00104 	movi	r3,4
 110:	0009883a 	mov	r4,zero
 114:	01a04034 	movhi	r6,33024
 118:	01eaaaf4 	movhi	r7,43691
 11c:	39eaaa84 	addi	r7,r7,-21846
 120:	01400584 	movi	r5,22
  unsigned int ret_code = 0x0;

  /* Write the default pattern at each of the power-of-two offsets. */
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
  {
    IOWR_32DIRECT(memory_base, offset, pattern);
 124:	1985883a 	add	r2,r3,r6
 128:	11c00035 	stwio	r7,0(r2)
  unsigned int antipattern  = 0x55555555;

  unsigned int ret_code = 0x0;

  /* Write the default pattern at each of the power-of-two offsets. */
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 12c:	21000044 	addi	r4,r4,1
 130:	18c7883a 	add	r3,r3,r3
 134:	217ffb1e 	bne	r4,r5,124 <main+0x5c>
    IOWR_32DIRECT(memory_base, offset, pattern);
  }

  /* Check for address bits stuck high. */
  test_offset = 0;
  IOWR_32DIRECT(memory_base, test_offset, antipattern);
 138:	00955574 	movhi	r2,21845
 13c:	10955544 	addi	r2,r2,21845
 140:	30800035 	stwio	r2,0(r6)
 144:	01000104 	movi	r4,4
 148:	000b883a 	mov	r5,zero
 14c:	02204034 	movhi	r8,33024
 150:	01eaaaf4 	movhi	r7,43691
 154:	39eaaa84 	addi	r7,r7,-21846
 158:	01800584 	movi	r6,22
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
  {
     if (IORD_32DIRECT(memory_base, offset) != pattern)
 15c:	2207883a 	add	r3,r4,r8
 160:	18800037 	ldwio	r2,0(r3)
  }

  /* Check for address bits stuck high. */
  test_offset = 0;
  IOWR_32DIRECT(memory_base, test_offset, antipattern);
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 164:	29400044 	addi	r5,r5,1
 168:	2109883a 	add	r4,r4,r4
  {
     if (IORD_32DIRECT(memory_base, offset) != pattern)
 16c:	11ffe51e 	bne	r2,r7,104 <main+0x3c>
  }

  /* Check for address bits stuck high. */
  test_offset = 0;
  IOWR_32DIRECT(memory_base, test_offset, antipattern);
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 170:	29bffa1e 	bne	r5,r6,15c <main+0x94>
 174:	000d883a 	mov	r6,zero
        break;
     }
  }

  /* Check for address bits stuck low or shorted. */
  IOWR_32DIRECT(memory_base, test_offset, pattern);
 178:	00a04034 	movhi	r2,33024
 17c:	00eaaaf4 	movhi	r3,43691
 180:	18eaaa84 	addi	r3,r3,-21846
 184:	10c00035 	stwio	r3,0(r2)
 188:	101f883a 	mov	r15,r2
 18c:	01c00104 	movi	r7,4
 190:	0013883a 	mov	r9,zero
 194:	03955574 	movhi	r14,21845
 198:	73955544 	addi	r14,r14,21845
 19c:	03400584 	movi	r13,22
  for (test_offset = sizeof(unsigned int); (test_offset & address_mask) != 0; test_offset <<= 1)
  {
    if (!ret_code)
 1a0:	3000121e 	bne	r6,zero,1ec <main+0x124>
    {
      IOWR_32DIRECT(memory_base, test_offset, antipattern);
 1a4:	3bd1883a 	add	r8,r7,r15
 1a8:	43800035 	stwio	r14,0(r8)
 1ac:	01000104 	movi	r4,4
 1b0:	000b883a 	mov	r5,zero
 1b4:	02a04034 	movhi	r10,33024
 1b8:	032aaaf4 	movhi	r12,43691
 1bc:	632aaa84 	addi	r12,r12,-21846
 1c0:	02c00584 	movi	r11,22
      for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
      {
        if ((IORD_32DIRECT(memory_base, offset) != pattern) && (offset != test_offset))
 1c4:	2285883a 	add	r2,r4,r10
 1c8:	10800037 	ldwio	r2,0(r2)
  for (test_offset = sizeof(unsigned int); (test_offset & address_mask) != 0; test_offset <<= 1)
  {
    if (!ret_code)
    {
      IOWR_32DIRECT(memory_base, test_offset, antipattern);
      for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 1cc:	29400044 	addi	r5,r5,1
      {
        if ((IORD_32DIRECT(memory_base, offset) != pattern) && (offset != test_offset))
 1d0:	13000326 	beq	r2,r12,1e0 <main+0x118>
 1d4:	21c00226 	beq	r4,r7,1e0 <main+0x118>
        {
          ret_code = (memory_base + test_offset);
 1d8:	3a8d883a 	add	r6,r7,r10
 1dc:	00000206 	br	1e8 <main+0x120>
  for (test_offset = sizeof(unsigned int); (test_offset & address_mask) != 0; test_offset <<= 1)
  {
    if (!ret_code)
    {
      IOWR_32DIRECT(memory_base, test_offset, antipattern);
      for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 1e0:	2109883a 	add	r4,r4,r4
 1e4:	2afff71e 	bne	r5,r11,1c4 <main+0xfc>
        {
          ret_code = (memory_base + test_offset);
          break;
        }
      }
      IOWR_32DIRECT(memory_base, test_offset, pattern);
 1e8:	40c00035 	stwio	r3,0(r8)
     }
  }

  /* Check for address bits stuck low or shorted. */
  IOWR_32DIRECT(memory_base, test_offset, pattern);
  for (test_offset = sizeof(unsigned int); (test_offset & address_mask) != 0; test_offset <<= 1)
 1ec:	4a400044 	addi	r9,r9,1
 1f0:	39cf883a 	add	r7,r7,r7
 1f4:	4b7fea1e 	bne	r9,r13,1a0 <main+0xd8>

  /* Test Address Bus. */
  if (!ret_code)
  {
    ret_code  = MemTestAddressBus(memory_base, memory_size);
    if  (ret_code)
 1f8:	30000226 	beq	r6,zero,204 <main+0x13c>
    	led_flash(5);
 1fc:	01000144 	movi	r4,5
 200:	00003d06 	br	2f8 <main+0x230>
static int MemTest8_16BitAccess(unsigned int memory_base)
{
  int ret_code = 0x0;

  /* Write 4 bytes */
  IOWR_8DIRECT(memory_base, 0, 0x0A);
 204:	01204034 	movhi	r4,33024
 208:	00800284 	movi	r2,10
 20c:	20800025 	stbio	r2,0(r4)
  IOWR_8DIRECT(memory_base, 1, 0x05);
 210:	00c00144 	movi	r3,5
 214:	00a04034 	movhi	r2,33024
 218:	10800044 	addi	r2,r2,1
 21c:	10c00025 	stbio	r3,0(r2)
  IOWR_8DIRECT(memory_base, 2, 0xA0);
 220:	01604034 	movhi	r5,33024
 224:	29400084 	addi	r5,r5,2
 228:	00802804 	movi	r2,160
 22c:	28800025 	stbio	r2,0(r5)
  IOWR_8DIRECT(memory_base, 3, 0x50);
 230:	00c01404 	movi	r3,80
 234:	00a04034 	movhi	r2,33024
 238:	108000c4 	addi	r2,r2,3
 23c:	10c00025 	stbio	r3,0(r2)

  /* Read it back as one word */
  if(IORD_32DIRECT(memory_base, 0) != 0x50A0050A)
 240:	20c00037 	ldwio	r3,0(r4)
 244:	00942834 	movhi	r2,20640
 248:	10814284 	addi	r2,r2,1290
 24c:	1880291e 	bne	r3,r2,2f4 <main+0x22c>
  }

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x50A0) ||
 250:	28c0002b 	ldhuio	r3,0(r5)
 254:	00942804 	movi	r2,20640
 258:	1880261e 	bne	r3,r2,2f4 <main+0x22c>
 25c:	20c0002b 	ldhuio	r3,0(r4)
 260:	00814284 	movi	r2,1290
 264:	1880231e 	bne	r3,r2,2f4 <main+0x22c>
 268:	00003206 	br	334 <main+0x26c>
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
 26c:	00a04034 	movhi	r2,33024
 270:	10800084 	addi	r2,r2,2
 274:	10c00023 	ldbuio	r3,0(r2)
 278:	00802804 	movi	r2,160
 27c:	18801d1e 	bne	r3,r2,2f4 <main+0x22c>
 280:	00a04034 	movhi	r2,33024
 284:	10800044 	addi	r2,r2,1
 288:	10c00023 	ldbuio	r3,0(r2)
 28c:	00800144 	movi	r2,5
 290:	1880181e 	bne	r3,r2,2f4 <main+0x22c>
 294:	00a04034 	movhi	r2,33024
 298:	10c00023 	ldbuio	r3,0(r2)
 29c:	00800284 	movi	r2,10
 2a0:	1880141e 	bne	r3,r2,2f4 <main+0x22c>
 2a4:	00002906 	br	34c <main+0x284>
  }

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x050A) ||
 2a8:	00a04034 	movhi	r2,33024
 2ac:	10c0002b 	ldhuio	r3,0(r2)
 2b0:	00942804 	movi	r2,20640
 2b4:	18800f1e 	bne	r3,r2,2f4 <main+0x22c>
 2b8:	00003206 	br	384 <main+0x2bc>
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
 2bc:	00a04034 	movhi	r2,33024
 2c0:	10800084 	addi	r2,r2,2
 2c4:	10c00023 	ldbuio	r3,0(r2)
 2c8:	00800284 	movi	r2,10
 2cc:	1880091e 	bne	r3,r2,2f4 <main+0x22c>
 2d0:	00a04034 	movhi	r2,33024
 2d4:	10800044 	addi	r2,r2,1
 2d8:	10c00023 	ldbuio	r3,0(r2)
 2dc:	00801404 	movi	r2,80
 2e0:	1880041e 	bne	r3,r2,2f4 <main+0x22c>
 2e4:	00a04034 	movhi	r2,33024
 2e8:	10c00023 	ldbuio	r3,0(r2)
 2ec:	00802804 	movi	r2,160
 2f0:	18800226 	beq	r3,r2,2fc <main+0x234>
  /* Test byte and half-word access. */
  if (!ret_code)
  {
    ret_code = MemTest8_16BitAccess(memory_base);
    if  (ret_code)
    	led_flash(8);
 2f4:	01000204 	movi	r4,8
 2f8:	000006c0 	call	6c <led_flash>
  int ch;

  while (1)
  {
	TestRam();
	usleep(500000);
 2fc:	01000234 	movhi	r4,8
 300:	21284804 	addi	r4,r4,-24288
 304:	00004540 	call	454 <usleep>
	IOWR_32DIRECT(LED_BASE,0,0);
 308:	04140004 	movi	r16,20480
 30c:	80000035 	stwio	zero,0(r16)
	usleep(500000);
 310:	01000234 	movhi	r4,8
 314:	21284804 	addi	r4,r4,-24288
 318:	00004540 	call	454 <usleep>
	IOWR_32DIRECT(LED_BASE,0,1);
 31c:	00800044 	movi	r2,1
 320:	80800035 	stwio	r2,0(r16)
	usleep(500000);
 324:	01000234 	movhi	r4,8
 328:	21284804 	addi	r4,r4,-24288
 32c:	00004540 	call	454 <usleep>
 330:	003f6806 	br	d4 <main+0xc>
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
 334:	00a04034 	movhi	r2,33024
 338:	108000c4 	addi	r2,r2,3
 33c:	10c00023 	ldbuio	r3,0(r2)
 340:	00801404 	movi	r2,80
 344:	18bfeb1e 	bne	r3,r2,2f4 <main+0x22c>
 348:	003fc806 	br	26c <main+0x1a4>
  }

  /* Write 2 half-words */
  if (!ret_code)
  {
    IOWR_16DIRECT(memory_base, 0, 0x50A0);
 34c:	00e04034 	movhi	r3,33024
 350:	00942804 	movi	r2,20640
 354:	1880002d 	sthio	r2,0(r3)
    IOWR_16DIRECT(memory_base, 2, 0x050A);
 358:	01204034 	movhi	r4,33024
 35c:	21000084 	addi	r4,r4,2
 360:	01414284 	movi	r5,1290
 364:	2140002d 	sthio	r5,0(r4)

    /* Read it back as one word */
    if(IORD_32DIRECT(memory_base, 0) != 0x050A50A0)
 368:	18c00037 	ldwio	r3,0(r3)
 36c:	008142b4 	movhi	r2,1290
 370:	10942804 	addi	r2,r2,20640
 374:	18bfdf1e 	bne	r3,r2,2f4 <main+0x22c>
  }

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x050A) ||
 378:	2080002b 	ldhuio	r2,0(r4)
 37c:	117fdd1e 	bne	r2,r5,2f4 <main+0x22c>
 380:	003fc906 	br	2a8 <main+0x1e0>
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
 384:	00a04034 	movhi	r2,33024
 388:	108000c4 	addi	r2,r2,3
 38c:	10c00023 	ldbuio	r3,0(r2)
 390:	00800144 	movi	r2,5
 394:	18bfd71e 	bne	r3,r2,2f4 <main+0x22c>
 398:	003fc806 	br	2bc <main+0x1f4>

0000039c <alt_load_section>:

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 39c:	2900051e 	bne	r5,r4,3b4 <alt_load_section+0x18>
 3a0:	f800283a 	ret
  {
    while( to != end )
    {
      *to++ = *from++;
 3a4:	20800017 	ldw	r2,0(r4)
 3a8:	21000104 	addi	r4,r4,4
 3ac:	28800015 	stw	r2,0(r5)
 3b0:	29400104 	addi	r5,r5,4
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 3b4:	29bffb1e 	bne	r5,r6,3a4 <alt_load_section+0x8>
 3b8:	f800283a 	ret

000003bc <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 3bc:	deffff04 	addi	sp,sp,-4
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 3c0:	01000034 	movhi	r4,0
 3c4:	2101ab04 	addi	r4,r4,1708
 3c8:	01400034 	movhi	r5,0
 3cc:	2941aa04 	addi	r5,r5,1704
 3d0:	01800034 	movhi	r6,0
 3d4:	3181ab04 	addi	r6,r6,1708
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 3d8:	dfc00015 	stw	ra,0(sp)
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 3dc:	000039c0 	call	39c <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 3e0:	01000034 	movhi	r4,0
 3e4:	21000804 	addi	r4,r4,32
 3e8:	01400034 	movhi	r5,0
 3ec:	29400804 	addi	r5,r5,32
 3f0:	01800034 	movhi	r6,0
 3f4:	31800804 	addi	r6,r6,32
 3f8:	000039c0 	call	39c <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 3fc:	01000034 	movhi	r4,0
 400:	2101aa04 	addi	r4,r4,1704
 404:	01400034 	movhi	r5,0
 408:	2941aa04 	addi	r5,r5,1704
 40c:	01800034 	movhi	r6,0
 410:	3181aa04 	addi	r6,r6,1704
 414:	000039c0 	call	39c <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 418:	00004f80 	call	4f8 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
 41c:	dfc00017 	ldw	ra,0(sp)
 420:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
 424:	00005101 	jmpi	510 <alt_icache_flush_all>

00000428 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 428:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 42c:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 430:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 434:	000045c0 	call	45c <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 438:	00004580 	call	458 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 43c:	d1200217 	ldw	r4,-32760(gp)
 440:	d1600317 	ldw	r5,-32756(gp)
 444:	d1a00417 	ldw	r6,-32752(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
 448:	dfc00017 	ldw	ra,0(sp)
 44c:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 450:	00000c81 	jmpi	c8 <main>

00000454 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
 454:	000047c1 	jmpi	47c <alt_busy_sleep>

00000458 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
}
 458:	f800283a 	ret

0000045c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 45c:	deffff04 	addi	sp,sp,-4
 460:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2, nios2);
 464:	000051c0 	call	51c <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 468:	00800044 	movi	r2,1
 46c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 470:	dfc00017 	ldw	ra,0(sp)
 474:	dec00104 	addi	sp,sp,4
 478:	f800283a 	ret

0000047c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 47c:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 480:	0140ccf4 	movhi	r5,819
 484:	294cccc4 	addi	r5,r5,13107
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 488:	dc000015 	stw	r16,0(sp)
 48c:	dfc00115 	stw	ra,4(sp)
 490:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 494:	00006980 	call	698 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 498:	10000f26 	beq	r2,zero,4d8 <alt_busy_sleep+0x5c>
 49c:	0007883a 	mov	r3,zero
 4a0:	01200034 	movhi	r4,32768
 4a4:	213fffc4 	addi	r4,r4,-1
 4a8:	017f3374 	movhi	r5,64717
 4ac:	29733344 	addi	r5,r5,-13107
 4b0:	00000406 	br	4c4 <alt_busy_sleep+0x48>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 4b4:	213fffc4 	addi	r4,r4,-1
 4b8:	203ffe1e 	bne	r4,zero,4b4 <alt_busy_sleep+0x38>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 4bc:	8161883a 	add	r16,r16,r5
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 4c0:	18c00044 	addi	r3,r3,1
 4c4:	18bffb16 	blt	r3,r2,4b4 <alt_busy_sleep+0x38>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 4c8:	80800a24 	muli	r2,r16,40
 4cc:	10bfffc4 	addi	r2,r2,-1
 4d0:	103ffe1e 	bne	r2,zero,4cc <alt_busy_sleep+0x50>
 4d4:	00000306 	br	4e4 <alt_busy_sleep+0x68>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 4d8:	80800a24 	muli	r2,r16,40
 4dc:	10bfffc4 	addi	r2,r2,-1
 4e0:	00bffe16 	blt	zero,r2,4dc <alt_busy_sleep+0x60>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
 4e4:	0005883a 	mov	r2,zero
 4e8:	dfc00117 	ldw	ra,4(sp)
 4ec:	dc000017 	ldw	r16,0(sp)
 4f0:	dec00204 	addi	sp,sp,8
 4f4:	f800283a 	ret

000004f8 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 4f8:	0005883a 	mov	r2,zero
 4fc:	00c20004 	movi	r3,2048
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 500:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 504:	10800804 	addi	r2,r2,32
 508:	10fffd1e 	bne	r2,r3,500 <alt_dcache_flush_all+0x8>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 50c:	f800283a 	ret

00000510 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 510:	0009883a 	mov	r4,zero
 514:	01440004 	movi	r5,4096
 518:	00005241 	jmpi	524 <alt_icache_flush>

0000051c <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
 51c:	000170fa 	wrctl	ienable,zero
}
 520:	f800283a 	ret

00000524 <alt_icache_flush>:
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
 524:	00840004 	movi	r2,4096
 528:	2007883a 	mov	r3,r4
 52c:	1140012e 	bgeu	r2,r5,534 <alt_icache_flush+0x10>
 530:	100b883a 	mov	r5,r2
 534:	194b883a 	add	r5,r3,r5
 538:	00000206 	br	544 <alt_icache_flush+0x20>

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 53c:	1800603a 	flushi	r3
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 540:	18c00804 	addi	r3,r3,32
 544:	197ffd36 	bltu	r3,r5,53c <alt_icache_flush+0x18>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 548:	208007cc 	andi	r2,r4,31
 54c:	10000126 	beq	r2,zero,554 <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 550:	1800603a 	flushi	r3
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 554:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 558:	f800283a 	ret

0000055c <udivmodsi4>:
 55c:	29001b2e 	bgeu	r5,r4,5cc <udivmodsi4+0x70>
 560:	28001a16 	blt	r5,zero,5cc <udivmodsi4+0x70>
 564:	00800044 	movi	r2,1
 568:	0007883a 	mov	r3,zero
 56c:	01c007c4 	movi	r7,31
 570:	00000306 	br	580 <udivmodsi4+0x24>
 574:	19c01326 	beq	r3,r7,5c4 <udivmodsi4+0x68>
 578:	18c00044 	addi	r3,r3,1
 57c:	28000416 	blt	r5,zero,590 <udivmodsi4+0x34>
 580:	294b883a 	add	r5,r5,r5
 584:	1085883a 	add	r2,r2,r2
 588:	293ffa36 	bltu	r5,r4,574 <udivmodsi4+0x18>
 58c:	10000d26 	beq	r2,zero,5c4 <udivmodsi4+0x68>
 590:	0007883a 	mov	r3,zero
 594:	21400236 	bltu	r4,r5,5a0 <udivmodsi4+0x44>
 598:	2149c83a 	sub	r4,r4,r5
 59c:	1886b03a 	or	r3,r3,r2
 5a0:	1004d07a 	srli	r2,r2,1
 5a4:	280ad07a 	srli	r5,r5,1
 5a8:	103ffa1e 	bne	r2,zero,594 <udivmodsi4+0x38>
 5ac:	30000226 	beq	r6,zero,5b8 <udivmodsi4+0x5c>
 5b0:	2005883a 	mov	r2,r4
 5b4:	f800283a 	ret
 5b8:	1809883a 	mov	r4,r3
 5bc:	2005883a 	mov	r2,r4
 5c0:	f800283a 	ret
 5c4:	0007883a 	mov	r3,zero
 5c8:	003ff806 	br	5ac <udivmodsi4+0x50>
 5cc:	00800044 	movi	r2,1
 5d0:	0007883a 	mov	r3,zero
 5d4:	003fef06 	br	594 <udivmodsi4+0x38>

000005d8 <__divsi3>:
 5d8:	defffe04 	addi	sp,sp,-8
 5dc:	dc000015 	stw	r16,0(sp)
 5e0:	dfc00115 	stw	ra,4(sp)
 5e4:	0021883a 	mov	r16,zero
 5e8:	20000c16 	blt	r4,zero,61c <__divsi3+0x44>
 5ec:	000d883a 	mov	r6,zero
 5f0:	28000e16 	blt	r5,zero,62c <__divsi3+0x54>
 5f4:	000055c0 	call	55c <udivmodsi4>
 5f8:	1007883a 	mov	r3,r2
 5fc:	8005003a 	cmpeq	r2,r16,zero
 600:	1000011e 	bne	r2,zero,608 <__divsi3+0x30>
 604:	00c7c83a 	sub	r3,zero,r3
 608:	1805883a 	mov	r2,r3
 60c:	dfc00117 	ldw	ra,4(sp)
 610:	dc000017 	ldw	r16,0(sp)
 614:	dec00204 	addi	sp,sp,8
 618:	f800283a 	ret
 61c:	0109c83a 	sub	r4,zero,r4
 620:	04000044 	movi	r16,1
 624:	000d883a 	mov	r6,zero
 628:	283ff20e 	bge	r5,zero,5f4 <__divsi3+0x1c>
 62c:	014bc83a 	sub	r5,zero,r5
 630:	8021003a 	cmpeq	r16,r16,zero
 634:	003fef06 	br	5f4 <__divsi3+0x1c>

00000638 <__modsi3>:
 638:	deffff04 	addi	sp,sp,-4
 63c:	dfc00015 	stw	ra,0(sp)
 640:	01800044 	movi	r6,1
 644:	2807883a 	mov	r3,r5
 648:	20000416 	blt	r4,zero,65c <__modsi3+0x24>
 64c:	28000c16 	blt	r5,zero,680 <__modsi3+0x48>
 650:	dfc00017 	ldw	ra,0(sp)
 654:	dec00104 	addi	sp,sp,4
 658:	000055c1 	jmpi	55c <udivmodsi4>
 65c:	0109c83a 	sub	r4,zero,r4
 660:	28000b16 	blt	r5,zero,690 <__modsi3+0x58>
 664:	180b883a 	mov	r5,r3
 668:	01800044 	movi	r6,1
 66c:	000055c0 	call	55c <udivmodsi4>
 670:	0085c83a 	sub	r2,zero,r2
 674:	dfc00017 	ldw	ra,0(sp)
 678:	dec00104 	addi	sp,sp,4
 67c:	f800283a 	ret
 680:	014bc83a 	sub	r5,zero,r5
 684:	dfc00017 	ldw	ra,0(sp)
 688:	dec00104 	addi	sp,sp,4
 68c:	000055c1 	jmpi	55c <udivmodsi4>
 690:	0147c83a 	sub	r3,zero,r5
 694:	003ff306 	br	664 <__modsi3+0x2c>

00000698 <__udivsi3>:
 698:	000d883a 	mov	r6,zero
 69c:	000055c1 	jmpi	55c <udivmodsi4>

000006a0 <__umodsi3>:
 6a0:	01800044 	movi	r6,1
 6a4:	000055c1 	jmpi	55c <udivmodsi4>
